/**
 * _gen-redirects.mjs
 *
 * Reads docs/lalunar-deliverables/url-mapping.csv and generates a TypeScript
 * redirect map at lib/redirects/codex-url-mapping.ts.
 *
 * Usage:  node scripts/_gen-redirects.mjs
 * No external dependencies — CSV is parsed manually.
 */

import { readFileSync, writeFileSync, mkdirSync } from "node:fs";
import { resolve, dirname } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = resolve(__dirname, "..");

const CSV_PATH = resolve(ROOT, "docs/lalunar-deliverables/url-mapping.csv");
const OUT_PATH = resolve(ROOT, "lib/redirects/codex-url-mapping.ts");

// ---------------------------------------------------------------------------
// 1. CSV helpers
// ---------------------------------------------------------------------------

/**
 * Parse a single CSV line into an array of field values.
 * Handles double-quoted fields (including commas and escaped "" inside quotes).
 */
function parseCsvLine(line) {
  const fields = [];
  let i = 0;
  const len = line.length;

  while (i <= len) {
    if (i === len) {
      // trailing comma produced an empty final field
      fields.push("");
      break;
    }

    if (line[i] === '"') {
      // Quoted field — scan until closing quote
      i++; // skip opening quote
      let value = "";
      while (i < len) {
        if (line[i] === '"') {
          if (i + 1 < len && line[i + 1] === '"') {
            // escaped quote ""
            value += '"';
            i += 2;
          } else {
            // closing quote
            i++; // skip closing quote
            break;
          }
        } else {
          value += line[i];
          i++;
        }
      }
      fields.push(value);
      // skip comma (or we're at end of line)
      if (i < len && line[i] === ",") i++;
    } else {
      // Unquoted field — scan until comma or end
      const start = i;
      while (i < len && line[i] !== ",") i++;
      fields.push(line.substring(start, i));
      if (i < len) i++; // skip comma
      else break;
    }
  }

  return fields;
}

/**
 * Strip a UTF-8 BOM if present.
 */
function stripBom(text) {
  return text.charCodeAt(0) === 0xfeff ? text.slice(1) : text;
}

/**
 * Remove trailing slash from a path, but keep "/" as-is.
 */
function trimTrailingSlash(url) {
  return url.length > 1 && url.endsWith("/") ? url.slice(0, -1) : url;
}

// ---------------------------------------------------------------------------
// 2. Read & parse CSV
// ---------------------------------------------------------------------------

const raw = stripBom(readFileSync(CSV_PATH, "utf-8"));
const lines = raw.split(/\r?\n/).filter((l) => l.trim() !== "");

// First line is the header — build a column-name -> index map
const header = parseCsvLine(lines[0]);
const colIndex = Object.fromEntries(header.map((name, idx) => [name.trim(), idx]));

const COL_NEW_URL = colIndex["new_url"];
const COL_HINTS = colIndex["current_url_hints"];

if (COL_NEW_URL === undefined || COL_HINTS === undefined) {
  console.error("Could not find required columns (new_url, current_url_hints) in header:");
  console.error(header);
  process.exit(1);
}

// ---------------------------------------------------------------------------
// 3. Build redirect entries
// ---------------------------------------------------------------------------

/** @type {Map<string, { source: string; destination: string; permanent: true }>} */
const seen = new Map(); // keyed by source to deduplicate

for (let r = 1; r < lines.length; r++) {
  const fields = parseCsvLine(lines[r]);
  const newUrl = (fields[COL_NEW_URL] ?? "").trim();
  const hints = (fields[COL_HINTS] ?? "").trim();

  if (!newUrl || !hints) continue;

  const destination = trimTrailingSlash(newUrl);

  // current_url_hints is pipe-separated
  const hintUrls = hints.split("|").map((h) => h.trim()).filter(Boolean);

  for (const hint of hintUrls) {
    const source = trimTrailingSlash(hint);

    // Skip self-redirects
    if (source === destination) continue;

    // Deduplicate by source (first occurrence wins)
    if (seen.has(source)) continue;

    seen.set(source, { source, destination, permanent: true });
  }
}

const redirects = [...seen.values()];

// ---------------------------------------------------------------------------
// 4. Write TypeScript output
// ---------------------------------------------------------------------------

const tsLines = redirects.map(
  (r) =>
    `  { source: ${JSON.stringify(r.source)}, destination: ${JSON.stringify(r.destination)}, permanent: true },`,
);

const tsContent = `// Auto-generated by scripts/_gen-redirects.mjs — do not edit manually.

export const codexUrlMappingRedirects = [
${tsLines.join("\n")}
];
`;

mkdirSync(dirname(OUT_PATH), { recursive: true });
writeFileSync(OUT_PATH, tsContent, "utf-8");

console.log(`Wrote ${redirects.length} redirects to ${OUT_PATH}`);
